/**
 * Edge Function template for performing AI-powered search on databases created by the GitHub Action.
 * 
 * This template provides a ready-to-use Edge Function that users can copy and paste 
 * into their SQLite Cloud project to enable semantic search capabilities on the 
 * documentation database generated by the sqlite-aisearch-action GitHub Action.
 * 
 * The function combines vector embeddings with full-text search using Reciprocal 
 * Rank Fusion (RRF) to deliver accurate and contextually relevant search results.
 * 
 * See README.md for deployment instructions.
 */

//---- CONFIGURATION ----
const sqliteAIBaseUrl = "https://aiserver.vital-rhino.eks.euc1.ryujaz.sqlite.cloud";
const sqliteAIAPI = "/v1/ai/embeddings"
//-----------------------

const requestid = request.params.requestid;
const query = request.params.query;

// get embedding from sqlite-ai-server
const data = {"text": query };
const response = await fetch(sqliteAIBaseUrl + sqliteAIAPI, {
    method: "POST",
    headers: {
        "Content-Type": "application/json"
    },
    body: JSON.stringify(data)
});

if (!response.ok) {
    throw new Error("Failed to generate embedding. " + response.statusText);
}

const result = await response.json();
const query_embedding = result.data.embedding;

// clean query for full-text search
const query_fts = (query.toLowerCase().match(/\b\w+\b/g) || []).join(" ") + "*";

// --- TEST ---
//const test_embedding = await connection.sql('SELECT embedding FROM chunks LIMIT 1;');
//const query_embedding = test_embedding[0].embedding;
// ------------

// Vector configuration must match the embedding parameters used during database generation
await connection.sql("SELECT vector_init('chunks', 'embedding', 'type=INT8,dimension=768,distance=cosine')");

const res = await connection.sql(
    `
    -- sqlite-vector KNN vector search results
    WITH vec_matches AS (
        SELECT
            v.rowid AS chunk_id,
            row_number() OVER (ORDER BY v.distance) AS rank_number,
            v.distance
        FROM vector_quantize_scan('chunks', 'embedding', ?, 10) AS v
    ),
    -- Full-text search results
    fts_matches AS (
        SELECT
            chunks_fts.rowid AS chunk_id,
            row_number() OVER (ORDER BY rank) AS rank_number,
            rank AS score
        FROM chunks_fts
        WHERE chunks_fts MATCH ?
        LIMIT 10
    ),
    -- combine FTS5 + vector search results with RRF
    matches AS (
        SELECT
            COALESCE(vec_matches.chunk_id, fts_matches.chunk_id) AS chunk_id,
            vec_matches.rank_number AS vec_rank,
            fts_matches.rank_number AS fts_rank,
            -- Reciprocal Rank Fusion score
            (
                COALESCE(1.0 / (60 + vec_matches.rank_number), 0.0) * 1.0 +
                COALESCE(1.0 / (60 + fts_matches.rank_number), 0.0) * 1.0
            ) AS combined_rank,
            vec_matches.distance AS vec_distance,
            fts_matches.score AS fts_score
        FROM vec_matches
            FULL OUTER JOIN fts_matches
                ON vec_matches.chunk_id = fts_matches.chunk_id
    )
    SELECT
        documents.id,
        documents.uri,
        documents.content as document_content,
        documents.metadata,
        chunks.content AS snippet,
        vec_rank,
        fts_rank,
        combined_rank,
        vec_distance,
        fts_score
    FROM matches
        JOIN chunks ON chunks.id = matches.chunk_id
        JOIN documents ON documents.id = chunks.document_id
    ORDER BY combined_rank DESC
    ;
    `, query_embedding, query_fts)


return {
    data: {
        search: res,
        requestid: requestid
    }
}
