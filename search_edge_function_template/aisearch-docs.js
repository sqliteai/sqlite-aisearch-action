/**
 * Edge Function template for performing AI-powered search on databases created by the GitHub Action.
 * 
 * This template provides a ready-to-use Edge Function that users can copy and paste 
 * into their SQLite Cloud project to enable semantic search capabilities on the 
 * documentation database generated by the sqlite-aisearch-action GitHub Action.
 * 
 * The function combines vector embeddings with full-text search using Reciprocal 
 * Rank Fusion (RRF) to deliver accurate and contextually relevant search results.
 * 
 * See README.md for deployment instructions.
 */

//---- CONFIGURATION ----
const sqliteAIBaseUrl = "https://aiserver.vital-rhino.eks.euc1.ryujaz.sqlite.cloud";
const sqliteAIAPI = "/v1/ai/embeddings"
//-----------------------

const query = request.params.query;
const limit = parseInt(request.params.limit) || 10; // Number of top results to return

// Get embedding from sqlite-ai-server
const data = {"text": query };
const response = await fetch(sqliteAIBaseUrl + sqliteAIAPI, {
    method: "POST",
    headers: {
        "Content-Type": "application/json"
    },
    body: JSON.stringify(data)
});

if (!response.ok) {
    throw new Error("Failed to generate embedding. " + response.statusText);
}

const result = await response.json();
const query_embedding = result.data.embedding;

// Clean query for full-text search
const query_fts = (query.toLowerCase().match(/\b\w+\b/g) || []).join(" ") + "*";

// Vector configuration must match the embedding parameters used during database generation
await connection.sql("SELECT vector_init('chunks', 'embedding', 'type=INT8,dimension=768,distance=cosine')");

const res = await connection.sql(
    `
        -- sqlite-vector KNN vector search results
    WITH vec_matches AS (
        SELECT
            v.rowid AS chunk_id,
            row_number() OVER (ORDER BY v.distance) AS rank_number,
            v.distance
        FROM vector_quantize_scan('chunks', 'embedding', ?, ?) AS v
    ),
    -- Full-text search results
    fts_matches AS (
        SELECT
            chunks_fts.rowid AS chunk_id,
            row_number() OVER (ORDER BY rank) AS rank_number,
            rank AS score
        FROM chunks_fts
        WHERE chunks_fts MATCH ?
        LIMIT ?
    ),
    -- combine FTS5 + vector search results with RRF
    matches AS (
        SELECT
            COALESCE(vec_matches.chunk_id, fts_matches.chunk_id) AS chunk_id,
            vec_matches.rank_number AS vec_rank,
            fts_matches.rank_number AS fts_rank,
            -- Reciprocal Rank Fusion score
            (
                COALESCE(1.0 / (60 + vec_matches.rank_number), 0.0) * 1.0 +
                COALESCE(1.0 / (60 + fts_matches.rank_number), 0.0) * 1.0
            ) AS combined_rank,
            vec_matches.distance AS vec_distance,
            fts_matches.score AS fts_score
        FROM vec_matches
            FULL OUTER JOIN fts_matches
                ON vec_matches.chunk_id = fts_matches.chunk_id
    )
        SELECT
            documents.id,
            documents.uri,
            documents.content as document_content,
            documents.metadata,
            chunks.content AS snippet,
            vec_rank,
            fts_rank,
            combined_rank,
            vec_distance,
            fts_score
        FROM matches
            JOIN chunks ON chunks.id = matches.chunk_id
            JOIN documents ON documents.id = chunks.document_id
    ORDER BY combined_rank DESC
    ;
    `, query_embedding, limit, query_fts, limit)

// The results from the query may contain multiple resulting chunks per document.
// We want to return one result per document, so we will group by document id and take
// the top-ranked chunk as a snippet.
const documentsChunk = new Map();
res.forEach(item => {
    if (!documentsChunk.has(item.id) || item.combined_rank > documentsChunk.get(item.id).combined_rank) {
        documentsChunk.set(item.id, item);
    }
});
const topResults = Array.from(documentsChunk.values()).slice(0, limit);

// ----- URLs for results -----
// Customize this section based on how URLs should be constructed for your documents.
// This example uses 'base_url' from metadata and 'slug' if available, otherwise derives from URI.
// ----------------------------
const resultsWithUrls = topResults
    .map(item => {
        const metadata = JSON.parse(item.metadata);
        const baseUrl = metadata.base_url;
        const slug = metadata.extracted?.slug;
        const uri = item.uri;
        
        let fullUrl;
        if (slug) {
            fullUrl = `${baseUrl}${slug}`;
        } else {
            const uriWithoutExtension = uri
                .toLowerCase()
                .replace(/\.(mdx?|md)$/i, '');
            fullUrl = `${baseUrl}${uriWithoutExtension}`;
        }
        
        return {
            id: item.id,
            url: fullUrl,
            title: metadata.extracted?.title || metadata.generated?.title,
            snippet: item.snippet,
        };
    });

return {
    data: {
        /**
         * @type {Array<{id: number, url: string, title: string, snippet: string}>}
         * The search results with constructed URLs, titles, and snippets.
         */
        search: resultsWithUrls
    }
}
